{
    "code": {
        "utils.py": "\nimport json\nfrom typing import Union, Optional\nimport time\nimport os\nimport re\nimport base64\nfrom base64 import b64encode\nimport hashlib\nfrom scalecodec.utils.ss58 import ss58_encode, ss58_decode, get_ss58_format, is_valid_ss58_address\nfrom scalecodec.base import ScaleBytes\nfrom bip39 import bip39_to_mini_secret, bip39_generate, bip39_validate\nimport sr25519\nimport ed25519_zebra\nimport commune as c\nimport re\nfrom hashlib import blake2b\nimport base64\nimport json\nfrom os import urandom\nfrom typing import Union\nfrom nacl.hashlib import scrypt\nfrom nacl.secret import SecretBox\nfrom sr25519 import pair_from_ed25519_secret_key\nfrom scalecodec.types import Bytes\nimport hashlib\nimport hmac\nimport struct\nfrom eth_keys.datatypes import Signature, PrivateKey\nfrom eth_utils import to_checksum_address, keccak as eth_utils_keccak\nfrom ecdsa.curves import SECP256k1\n\nBIP39_PBKDF2_ROUNDS = 2048\nBIP39_SALT_MODIFIER = \"mnemonic\"\nBIP32_PRIVDEV = 0x80000000\nBIP32_CURVE = SECP256k1\nBIP32_SEED_MODIFIER = b'Bitcoin seed'\nETH_DERIVATION_PATH = \"m/44'/60'/0'/0\"\nJUNCTION_ID_LEN = 32\nRE_JUNCTION = r'(\\/\\/?)([^/]+)'\n\n\ndef is_valid_ss58_address(address: str) -> bool:\n    \"\"\"\n    Check if the given address is a valid SS58 address\n    \"\"\"\n    try:\n        ss58_decode(address)\n        return True\n    except:\n        return False\n\n\n\ndef str2bytes( data: str, mode: str = 'hex') -> bytes:\n    if mode in ['utf-8']:\n        return bytes(data, mode)\n    elif mode in ['hex']:\n        return bytes.fromhex(data)\n\n\ndef is_int(value: str) -> bool:\n    \"\"\"\n    Check if the provided string is an integer\n    \"\"\"\n    try:\n        int(value)\n        return True\n    except ValueError:\n        return False\n\ndef is_valid_ecdsa_address(address: str) -> bool:\n    \"\"\"\n    Check if the given address is a valid ECDSA address\n    \"\"\"\n    try:\n        return len(bytes.fromhex(address)) == 20\n    except:\n        return False\nclass PublicKey:\n    def __init__(self, private_key):\n        self.point = int.from_bytes(private_key, byteorder='big') * BIP32_CURVE.generator\n\n    def __bytes__(self):\n        xstr = int(self.point.x()).to_bytes(32, byteorder='big')\n        parity = int(self.point.y()) & 1\n        return (2 + parity).to_bytes(1, byteorder='big') + xstr\n\n    def address(self):\n        x = int(self.point.x())\n        y = int(self.point.y())\n        s = x.to_bytes(32, 'big') + y.to_bytes(32, 'big')\n        return to_checksum_address(eth_utils_keccak(s)[12:])\n\ndef mnemonic_to_bip39seed(mnemonic, passphrase):\n    mnemonic = bytes(mnemonic, 'utf8')\n    salt = bytes(BIP39_SALT_MODIFIER + passphrase, 'utf8')\n    return hashlib.pbkdf2_hmac('sha512', mnemonic, salt, BIP39_PBKDF2_ROUNDS)\n\ndef bip39seed_to_bip32masternode(seed):\n    h = hmac.new(BIP32_SEED_MODIFIER, seed, hashlib.sha512).digest()\n    key, chain_code = h[:32], h[32:]\n    return key, chain_code\n\ndef derive_bip32childkey(parent_key, parent_chain_code, i):\n    assert len(parent_key) == 32\n    assert len(parent_chain_code) == 32\n    k = parent_chain_code\n    if (i & BIP32_PRIVDEV) != 0:\n        key = b'\\x00' + parent_key\n    else:\n        key = bytes(PublicKey(parent_key))\n    d = key + struct.pack('>L', i)\n    while True:\n        h = hmac.new(k, d, hashlib.sha512).digest()\n        key, chain_code = h[:32], h[32:]\n        a = int.from_bytes(key, byteorder='big')\n        b = int.from_bytes(parent_key, byteorder='big')\n        key = (a + b) % int(BIP32_CURVE.order)\n        if a < BIP32_CURVE.order and key != 0:\n            key = key.to_bytes(32, byteorder='big')\n            break\n        d = b'\\x01' + h[32:] + struct.pack('>L', i)\n    return key, chain_code\n\ndef parse_derivation_path(str_derivation_path):\n    path = []\n    if str_derivation_path[0:2] != 'm/':\n        raise ValueError(\"Can't recognize derivation path. It should look like \\\"m/44'/60/0'/0\\\".\")\n    for i in str_derivation_path.lstrip('m/').split('/'):\n        if \"'\" in i:\n            path.append(BIP32_PRIVDEV + int(i[:-1]))\n        else:\n            path.append(int(i))\n    return path\n\n\ndef mnemonic_to_ecdsa_private_key(mnemonic: str, str_derivation_path: str = None, passphrase: str = \"\") -> bytes:\n\n    if str_derivation_path is None:\n        str_derivation_path = f'{ETH_DERIVATION_PATH}/0'\n\n    derivation_path = parse_derivation_path(str_derivation_path)\n    bip39seed = mnemonic_to_bip39seed(mnemonic, passphrase)\n    master_private_key, master_chain_code = bip39seed_to_bip32masternode(bip39seed)\n    private_key, chain_code = master_private_key, master_chain_code\n    for i in derivation_path:\n        private_key, chain_code = derive_bip32childkey(private_key, chain_code, i)\n    return private_key\n\n\ndef ecdsa_sign(private_key: bytes, message: bytes) -> bytes:\n    signer = PrivateKey(private_key)\n    return signer.sign_msg(message).to_bytes()\n\n\ndef ecdsa_verify(signature: bytes, data: bytes, address: bytes) -> bool:\n    signature_obj = Signature(signature)\n    recovered_pubkey = signature_obj.recover_public_key_from_msg(data)\n    return recovered_pubkey.to_canonical_address() == address\n\nNONCE_LENGTH = 24\nSCRYPT_LENGTH = 32 + (3 * 4)\nPKCS8_DIVIDER = bytes([161, 35, 3, 33, 0])\nPKCS8_HEADER = bytes([48, 83, 2, 1, 1, 48, 5, 6, 3, 43, 101, 112, 4, 34, 4, 32])\nPUB_LENGTH = 32\nSALT_LENGTH = 32\nSEC_LENGTH = 64\nSEED_LENGTH = 32\nSCRYPT_N = 1 << 15\nSCRYPT_P = 1\nSCRYPT_R = 8\n\ndef decode_pair_from_encrypted_json(json_data: Union[str, dict], passphrase: str) -> tuple:\n    \"\"\"\n    Decodes encrypted PKCS#8 message from PolkadotJS JSON format\n\n    Parameters\n    ----------\n    json_data\n    passphrase\n\n    Returns\n    -------\n    tuple containing private and public key\n    \"\"\"\n    if type(json_data) is str:\n        json_data = json.loads(json_data)\n\n    # Check requirements\n    if json_data.get('encoding', {}).get('version') != \"3\":\n        raise ValueError(\"Unsupported JSON format\")\n\n    encrypted = base64.b64decode(json_data['encoded'])\n\n    if 'scrypt' in json_data['encoding']['type']:\n        salt = encrypted[0:32]\n        n = int.from_bytes(encrypted[32:36], byteorder='little')\n        p = int.from_bytes(encrypted[36:40], byteorder='little')\n        r = int.from_bytes(encrypted[40:44], byteorder='little')\n\n        password = scrypt(passphrase.encode(), salt, n=n, r=r, p=p, dklen=32, maxmem=2 ** 26)\n        encrypted = encrypted[SCRYPT_LENGTH:]\n\n    else:\n        password = passphrase.encode().rjust(32, b'\\x00')\n\n    if \"xsalsa20-poly1305\" not in json_data['encoding']['type']:\n        raise ValueError(\"Unsupported encoding type\")\n\n    nonce = encrypted[0:NONCE_LENGTH]\n    message = encrypted[NONCE_LENGTH:]\n\n    secret_box = SecretBox(key=password)\n    decrypted = secret_box.decrypt(message, nonce)\n\n    # Decode PKCS8 message\n    secret_key, public_key = decode_pkcs8(decrypted)\n\n    if 'sr25519' in json_data['encoding']['content']:\n        # Secret key from PolkadotJS is an Ed25519 expanded secret key, so has to be converted\n        # https://github.com/polkadot-js/wasm/blob/master/packages/wasm-crypto/src/rs/sr25519.rs#L125\n        converted_public_key, secret_key = pair_from_ed25519_secret_key(secret_key)\n        assert(public_key == converted_public_key)\n\n    return secret_key, public_key\n\ndef decode_pkcs8(ciphertext: bytes) -> tuple:\n    current_offset = 0\n\n    header = ciphertext[current_offset:len(PKCS8_HEADER)]\n    if header != PKCS8_HEADER:\n        raise ValueError(\"Invalid Pkcs8 header found in body\")\n\n    current_offset += len(PKCS8_HEADER)\n\n    secret_key = ciphertext[current_offset:current_offset + SEC_LENGTH]\n    current_offset += SEC_LENGTH\n\n    divider = ciphertext[current_offset:current_offset + len(PKCS8_DIVIDER)]\n\n    if divider != PKCS8_DIVIDER:\n        raise ValueError(\"Invalid Pkcs8 divider found in body\")\n\n    current_offset += len(PKCS8_DIVIDER)\n\n    public_key = ciphertext[current_offset: current_offset + PUB_LENGTH]\n\n    return secret_key, public_key\n\ndef encode_pkcs8(public_key: bytes, private_key: bytes) -> bytes:\n    return PKCS8_HEADER + private_key + PKCS8_DIVIDER + public_key\n\ndef encode_pair(public_key: bytes, private_key: bytes, passphrase: str) -> bytes:\n    \"\"\"\n    Encode a public/private pair to PKCS#8 format, encrypted with provided passphrase\n\n    Parameters\n    ----------\n    public_key: 32 bytes public key\n    private_key: 64 bytes private key\n    passphrase: passphrase to encrypt the PKCS#8 message\n\n    Returns\n    -------\n    (Encrypted) PKCS#8 message bytes\n    \"\"\"\n    message = encode_pkcs8(public_key, private_key)\n\n    salt = urandom(SALT_LENGTH)\n    password = scrypt(passphrase.encode(), salt, n=SCRYPT_N, r=SCRYPT_R, p=SCRYPT_P, dklen=32, maxmem=2 ** 26)\n\n    secret_box = SecretBox(key=password)\n    message = secret_box.encrypt(message)\n\n    scrypt_params = SCRYPT_N.to_bytes(4, 'little') + SCRYPT_P.to_bytes(4, 'little') + SCRYPT_R.to_bytes(4, 'little')\n\n    return salt + scrypt_params + message.nonce + message.ciphertext\n\n\n\n\ndef python2str(x):\n    from copy import deepcopy\n    import json\n    x = deepcopy(x)\n    input_type = type(x)\n    if input_type == str:\n        return x\n    if input_type in [dict]:\n        x = json.dumps(x)\n    elif input_type in [bytes]:\n        x = bytes2str(x)\n    elif input_type in [list, tuple, set]:\n        x = json.dumps(list(x))\n    elif input_type in [int, float, bool]:\n        x = str(x)\n        \n    return x\n\nclass DeriveJunction:\n    def __init__(self, chain_code, is_hard=False):\n        self.chain_code = chain_code\n        self.is_hard = is_hard\n\n    @classmethod\n    def from_derive_path(cls, path: str, is_hard=False):\n\n        if path.isnumeric():\n            byte_length = ceil(int(path).bit_length() / 8)\n            chain_code = int(path).to_bytes(byte_length, 'little').ljust(32, b'\\x00')\n\n        else:\n            path_scale = Bytes()\n            path_scale.encode(path)\n\n            if len(path_scale.data) > JUNCTION_ID_LEN:\n                chain_code = blake2b(path_scale.data.data, digest_size=32).digest()\n            else:\n                chain_code = bytes(path_scale.data.data.ljust(32, b'\\x00'))\n\n        return cls(chain_code=chain_code, is_hard=is_hard)\n\ndef extract_derive_path(derive_path: str):\n\n    path_check = ''\n    junctions = []\n    paths = re.findall(RE_JUNCTION, derive_path)\n\n    if paths:\n        path_check = ''.join(''.join(path) for path in paths)\n\n        for path_separator, path_value in paths:\n            junctions.append(DeriveJunction.from_derive_path(\n                path=path_value, is_hard=path_separator == '//')\n            )\n\n    if path_check != derive_path:\n        raise ValueError('Reconstructed path \"{}\" does not match input'.format(path_check))\n\n    return junctions\n\ndef bytes2str(data: bytes, mode: str = 'utf-8') -> str:\n    if hasattr(data, 'hex'):\n        return data.hex()\n    else:\n        if isinstance(data, str):\n            return data\n        return bytes.decode(data, mode)\n\n\n\ndef valid_h160_address(cls, address):\n    # Check if it starts with '0x'\n    if not address.startswith('0x'):\n        return False\n    \n    # Remove '0x' prefix\n    address = address[2:]\n    \n    # Check length\n    if len(address) != 40:\n        return False\n    \n    # Check if it contains only valid hex characters\n    if not re.match('^[0-9a-fA-F]{40}$', address):\n        return False\n    \n    return True\n\n\ndef is_mnemonic(mnemonic:str) -> bool:\n    \"\"\"\n    Check if the provided string is a valid mnemonic\n    \"\"\"\n    if not isinstance(mnemonic, str):\n        return False\n    return bip39_validate(mnemonic, self.language_code)"
    },
    "schema": {
        "from_derive_path": {
            "input": {
                "path": {
                    "value": "_empty",
                    "type": "_empty"
                },
                "is_hard": {
                    "value": false,
                    "type": "bool"
                }
            },
            "output": {
                "value": null,
                "type": "None"
            },
            "docs": null,
            "cost": 1,
            "name": "from_derive_path",
            "source": {
                "start": 306,
                "length": 17,
                "path": "~/commune/commune/core/key/utils.py",
                "code": null,
                "hash": "sha256:a65b26288ef5fec857195d60b24c5c46b76bab6d7eff795e0fa5ebafd09dd959",
                "end": 323
            }
        }
    },
    "name": "key.utils",
    "key": "5HYk8E8fZ5FZSiwtMLSZzQynSp8eWNGFhivSb86ZzuRTQ3pB",
    "founder": "5GKvu9qC8VPjXnofUxZP6zxTmvzTBCY1vpJAkh6gWF8YxPKy",
    "cid": "sha256:51a6fac6a01b8fc0f766dddc036d219ac48db1a7f1753cdba95078df87babd24",
    "time": 1746536278.960565,
    "signature": "0x2a19e9ff5d66cb8e3612a9249ed79a543e934b4631351382c46658c6d41bc96f34f9ff2a1ad12ea798450bed7e881a6e207611e8d2b6198325b6ab13452f978c"
}