{
    "code": {
        "extensions.py": "# Python Substrate Interface Library\n#\n# Copyright 2018-2023 Stichting Polkascan (Polkascan Foundation).\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nfrom typing import TYPE_CHECKING\n\nimport math\nfrom datetime import datetime, timedelta\n\n__all__ = ['Extension', 'SearchExtension', 'SubstrateNodeExtension']\n\nif TYPE_CHECKING:\n    from .base import SubstrateInterface\n\n\nclass Extension:\n    \"\"\"\n    Base class of all extensions\n    \"\"\"\n    def __init__(self):\n        self.substrate = None\n\n    def init(self, substrate: 'SubstrateInterface'):\n        \"\"\"\n        Initialization process of the extension. This function is being called by the ExtensionRegistry.\n\n        Parameters\n        ----------\n        substrate: SubstrateInterface\n\n        Returns\n        -------\n\n        \"\"\"\n        self.substrate: 'SubstrateInterface' = substrate\n\n    def close(self):\n        \"\"\"\n        Cleanup process of the extension. This function is being called by the ExtensionRegistry.\n\n        Returns\n        -------\n\n        \"\"\"\n        pass\n\n    def debug_message(self, message: str):\n        \"\"\"\n        Submits a debug message in the logger\n\n        Parameters\n        ----------\n        message: str\n\n        Returns\n        -------\n\n        \"\"\"\n        self.substrate.debug_message(f'Extension {self.__class__.__name__}: {message}')\n\n\nclass SearchExtension(Extension):\n    \"\"\"\n    Type of `Extension` that implements functionality to improve and enhance search capability\n    \"\"\"\n\n    def filter_events(self, **kwargs) -> list:\n        \"\"\"\n        Filters events to match provided search criteria e.g. block range, pallet name, accountID in attributes\n\n        Parameters\n        ----------\n        kwargs\n\n        Returns\n        -------\n        list\n        \"\"\"\n        raise NotImplementedError()\n\n    def filter_extrinsics(self, **kwargs) -> list:\n        \"\"\"\n        Filters extrinsics to match provided search criteria e.g. block range, pallet name, signed by accountID\n\n        Parameters\n        ----------\n        kwargs\n\n        Returns\n        -------\n\n        \"\"\"\n        raise NotImplementedError()\n\n    def search_block_number(self, block_datetime: datetime, block_time: int = 6, **kwargs) -> int:\n        \"\"\"\n        Search corresponding block number for provided `block_datetime`. the prediction tolerance is provided with\n        `block_time`\n\n        Parameters\n        ----------\n        block_datetime: datetime\n        block_time: int\n        kwargs\n\n        Returns\n        -------\n        int\n        \"\"\"\n        raise NotImplementedError()\n\n    def get_block_timestamp(self, block_number: int) -> int:\n        \"\"\"\n        Return a UNIX timestamp for given `block_number`.\n\n        Parameters\n        ----------\n        block_number: int The block_number to retrieve the timestamp for\n\n        Returns\n        -------\n        int\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass SubstrateNodeExtension(SearchExtension):\n    \"\"\"\n    Implementation of `SearchExtension` using only Substrate RPC methods. Could be significant inefficient.\n    \"\"\"\n\n    def filter_extrinsics(self, block_start: int = None, block_end: int = None, ss58_address: str = None,\n                          pallet_name: str = None, call_name: str = None) -> list:\n\n        if block_end is None:\n            block_end = self.substrate.get_block_number(None)\n\n        if block_start is None:\n            block_start = block_end\n\n        if block_start < 0:\n            block_start += block_end\n\n        result = []\n\n        for block_number in range(block_start, block_end + 1):\n            block_hash = self.substrate.get_block_hash(block_number)\n\n            for extrinsic in self.substrate.get_extrinsics(block_hash=block_hash):\n                if pallet_name is not None and pallet_name != extrinsic.value['call']['call_module']:\n                    continue\n\n                if call_name is not None and call_name != extrinsic.value['call']['call_function']:\n                    continue\n\n                result.append(extrinsic)\n\n        return result\n\n    def __init__(self, max_block_range: int = 100):\n        super().__init__()\n\n        self.max_block_range: int = max_block_range\n\n    def filter_events(self, block_start: int = None, block_end: int = None, pallet_name: str = None,\n                      event_name: str = None, account_id: str = None) -> list:\n\n        if block_end is None:\n            block_end = self.substrate.get_block_number(None)\n\n        if block_start is None:\n            block_start = block_end\n\n        if block_start < 0:\n            block_start += block_end\n\n        # Requirements check\n        if block_end - block_start > self.max_block_range:\n            raise ValueError(f\"max_block_range ({self.max_block_range}) exceeded\")\n\n        result = []\n\n        self.debug_message(f\"Retrieving events from #{block_start} to #{block_end}\")\n\n        for block_number in range(block_start, block_end + 1):\n            block_hash = self.substrate.get_block_hash(block_number)\n            for event in self.substrate.get_events(block_hash=block_hash):\n                if pallet_name is not None and pallet_name != event.value['event']['module_id']:\n                    continue\n\n                if event_name is not None and event_name != event.value['event']['event_id']:\n                    continue\n\n                # if account_id is not None:\n                #     found = False\n                #     for param in event.params:\n                #         if param['type'] == 'AccountId' and param['value'] == account_id:\n                #             found = True\n                #             break\n                #     if not found:\n                #         continue\n\n                result.append(event)\n\n        return result\n\n    def get_block_timestamp(self, block_number: int) -> int:\n        extrinsics = self.filter_extrinsics(\n            block_start=block_number, block_end=block_number, pallet_name=\"Timestamp\",\n            call_name=\"set\"\n        )\n        return extrinsics[0].value['call']['call_args'][0]['value'] / 1000\n\n    def search_block_number(self, block_datetime: datetime, block_time: int = 6, **kwargs) -> int:\n        \"\"\"\n        Search corresponding block number for provided `block_datetime`. the prediction tolerance is provided with\n        `block_time`\n\n        Parameters\n        ----------\n        block_datetime: datetime\n        block_time: int\n        kwargs\n\n        Returns\n        -------\n        int\n        \"\"\"\n        accuracy = timedelta(seconds=block_time)\n\n        target_block_timestamp = block_datetime.timestamp()\n\n        # Retrieve Timestamp extrinsic for chain tip\n        predicted_block_number = self.substrate.get_block_number(None)\n        current_timestamp = self.get_block_timestamp(predicted_block_number)\n        current_delta = current_timestamp - target_block_timestamp\n\n        self.debug_message(f\"Delta {current_delta} sec with chain tip #{predicted_block_number}\")\n\n        if current_delta < 0:\n            raise ValueError(\"Requested block_datetime is higher than current chain tip\")\n\n        while accuracy < timedelta(seconds=math.fabs(current_delta)):\n\n            predicted_block_number = math.ceil(predicted_block_number - current_delta / block_time)\n\n            if predicted_block_number < 0:\n                raise ValueError(f\"Requested datetime points before genesis of chain (#{predicted_block_number})\")\n\n            current_timestamp = self.get_block_timestamp(predicted_block_number)\n\n            # Predict target block number\n            current_delta = current_timestamp - target_block_timestamp\n\n            self.debug_message(f\"Current delta {current_delta} sec; predicted #{predicted_block_number}\")\n\n        self.debug_message(f\"Accepted prediction #{predicted_block_number}\")\n\n        return predicted_block_number\n\n\n# Backwards compatibility\nclass SubstrateNodeSearchExtension(SubstrateNodeExtension):\n    pass\n"
    },
    "schema": {},
    "name": "subspace.extensions",
    "key": "5DAAnqHRyZZPRJG5BfTrmfLcEAbHPZLDaG2NG2bBPvpaS7RN",
    "founder": "5GKvu9qC8VPjXnofUxZP6zxTmvzTBCY1vpJAkh6gWF8YxPKy",
    "cid": "sha256:e727bceeda0e64a0122f50c0938b4de44f46c34fc6e093ef2c33d7ff43cf29be",
    "time": 1746536239.291765,
    "signature": "0x56a05c8a05b17c7e3a7a595d57de02d1ebd847536911f86f46bcacbd6dab447a715c39e02093d5590d17d45c646782da1e0eb1c2dc17065288bb3b387b57b88b"
}