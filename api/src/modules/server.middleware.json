{
    "code": {
        "middleware.py": "\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import JSONResponse\nimport json\nimport commune as c\nimport time\nimport asyncio\n\nclass Middleware(BaseHTTPMiddleware):\n    def __init__(self, app, \n                max_bytes: int = 1000000, \n                max_requests: int = 1000,\n                auth_module = 'server.auth',\n                tx_collector_module = 'server.txcollector',\n                ):\n        super().__init__(app)\n        self.max_bytes = max_bytes\n        self.max_requests = max_requests\n        self.auth = c.module(auth_module)()\n        self.tx_collector = c.module(tx_collector_module)()\n        self.request_count = 0\n        self.last_reset = time.time()\n        \n    async def dispatch(self, request: Request, call_next):\n        # Rate limiting\n        current_time = time.time()\n        if current_time - self.last_reset > 60:  # Reset counter every minute\n            self.request_count = 0\n            self.last_reset = current_time\n            \n        self.request_count += 1\n        if self.request_count > self.max_requests:\n            return JSONResponse(\n                status_code=429, \n                content={\"error\": \"Too many requests\", \"retry_after\": 60 - (current_time - self.last_reset)}\n            )\n            \n        # Size validation\n        content_length = request.headers.get('content-length')\n        if content_length and int(content_length) > self.max_bytes:\n            return JSONResponse(status_code=413, content={\"error\": \"Request too large\"})\n        \n        # Verify authentication\n        try:\n            # Clone the request headers for verification\n            headers = dict(request.headers)\n            \n            # For POST requests with JSON body, verify the payload matches the signature\n            if request.method == \"POST\" and 'token' in headers:\n                body = await request.body()\n                if len(body) > self.max_bytes:\n                    return JSONResponse(status_code=413, content={\"error\": \"Request too large\"})\n                \n                # Parse the body to verify it against the token\n                try:\n                    body_json = json.loads(body)\n                    # Verify the token matches the request data\n                    verified = self.auth.verify_headers(headers, data=body_json)\n                    \n                    # Store request metadata for transaction tracking\n                    request_info = {\n                        'client': verified,\n                        'timestamp': time.time(),\n                        'path': str(request.url.path),\n                        'method': request.method,\n                        'ip': request.client.host if request.client else None\n                    }\n                    \n                    # Asynchronously log the transaction\n                    asyncio.create_task(self.tx_collector.record_transaction(request_info))\n                    \n                except json.JSONDecodeError:\n                    return JSONResponse(status_code=400, content={\"error\": \"Invalid JSON in request body\"})\n                except Exception as e:\n                    return JSONResponse(status_code=401, content={\"error\": f\"Authentication failed: {str(e)}\"})\n        except Exception as e:\n            # If verification fails but no token was provided, let the request through\n            # The endpoint will handle authentication if needed\n            pass\n            \n        # Continue processing the request\n        response = await call_next(request)\n        return response\n"
    },
    "schema": {},
    "name": "server.middleware",
    "key": "5GHUafCcigyVj1quAwDRndez2mBDWT2F2kMPbVgnPvNK6NS4",
    "founder": "5GKvu9qC8VPjXnofUxZP6zxTmvzTBCY1vpJAkh6gWF8YxPKy",
    "cid": "sha256:53ddfad4f92a9e97091593cbef19fef926116b955da519e62c27490a0b5d1747",
    "time": 1746536235.273785,
    "signature": "0x5c16d882497b939066cc9e474aa068e3a8555478e98f23d43fe57f17a94f9c073e8da6c32eed5a4cb6f9df61d523bc51ef3feabcf701510338ac4da4da061c89"
}